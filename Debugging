import tkinter as tk
from tkinter import ttk
import requests
from datetime import datetime

class EventFinder:
    def __init__(self, root):
        self.root = root
        self.root.title("Event Finder Pro")
        self.root.geometry("900x700")
        
        # Use your 50-character API key
        self.API_KEY = "6CGROMFISJVD5Z5IQ3VEHSGF4CKXJFFRMGDEMNNLUBLR7H2DJ7"
        
        self.create_widgets()
        
        # Test API connection on startup
        self.test_api_connection()

    def create_widgets(self):
        # Main container
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Search frame
        search_frame = ttk.LabelFrame(main_frame, text="Search Parameters", padding="10")
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="Location:").grid(row=0, column=0, sticky=tk.W)
        self.location_entry = ttk.Entry(search_frame, width=40)
        self.location_entry.grid(row=0, column=1, padx=5)
        
        ttk.Label(search_frame, text="Category:").grid(row=1, column=0, sticky=tk.W)
        self.category_combo = ttk.Combobox(search_frame, values=[
            "", "music", "business", "food", "arts", "sports"
        ])
        self.category_combo.grid(row=1, column=1, padx=5, pady=5, sticky=tk.W)
        
        search_btn = ttk.Button(
            search_frame, 
            text="Find Events", 
            command=self.search_events
        )
        search_btn.grid(row=2, column=0, columnspan=2, pady=10)
        
        # Results frame
        results_frame = ttk.LabelFrame(main_frame, text="Event Results", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True)
        
        # Treeview for results
        self.tree = ttk.Treeview(
            results_frame, 
            columns=("date", "venue", "price"), 
            show="headings",
            height=15
        )
        
        self.tree.heading("#0", text="Event")
        self.tree.heading("date", text="Date")
        self.tree.heading("venue", text="Venue")
        self.tree.heading("price", text="Price")
        
        self.tree.column("#0", width=300, stretch=tk.YES)
        self.tree.column("date", width=150)
        self.tree.column("venue", width=200)
        self.tree.column("price", width=100)
        
        scrollbar = ttk.Scrollbar(results_frame, orient=tk.VERTICAL, command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Status bar
        self.status_var = tk.StringVar()
        self.status_var.set("Ready")
        ttk.Label(
            self.root, 
            textvariable=self.status_var,
            relief=tk.SUNKEN,
            anchor=tk.W
        ).pack(fill=tk.X)

    def test_api_connection(self):
        """Test if API key is valid"""
        url = "https://www.eventbriteapi.com/v3/users/me/"
        try:
            response = requests.get(
                url,
                headers={
                    "Authorization": f"Bearer {self.API_KEY}",
                    "Content-Type": "application/json"
                },
                timeout=5
            )
            
            if response.status_code == 200:
                self.status_var.set("API Connected")
                return True
            else:
                self.status_var.set(f"API Error: {response.status_code}")
                return False
                
        except Exception as e:
            self.status_var.set(f"Connection Failed: {str(e)}")
            return False

    def search_events(self):
        location = self.location_entry.get().strip()
        category = self.category_combo.get().strip()
        
        if not location:
            self.status_var.set("Please enter a location")
            return
            
        # Clear previous results
        for item in self.tree.get_children():
            self.tree.delete(item)
            
        self.status_var.set("Searching events...")
        self.root.update()  # Force UI update
        
        params = {
            "location.address": location,
            "expand": "venue,price",
            "sort_by": "date"
        }
        
        if category:
            params["categories"] = category
            
        try:
            response = requests.get(
                "https://www.eventbriteapi.com/v3/events/search/",
                headers={
                    "Authorization": f"Bearer {self.API_KEY}",
                    "Content-Type": "application/json"
                },
                params=params,
                timeout=10
            )
            
            if response.status_code == 200:
                self.display_events(response.json())
            else:
                error = response.json().get('error_description', 'Unknown error')
                self.status_var.set(f"Error {response.status_code}: {error}")
                
        except requests.exceptions.RequestException as e:
            self.status_var.set(f"Network error: {str(e)}")

    def display_events(self, data):
        events = data.get("events", [])
        
        if not events:
            self.status_var.set("No events found")
            return
            
        for event in events[:20]:  # Show first 20 events
            name = event.get("name", {}).get("text", "Untitled Event")
            
            # Format date
            start = event.get("start", {}).get("local")
            date_str = self.format_date(start) if start else "Date not specified"
            
            # Get venue
            venue = event.get("venue", {})
            venue_name = venue.get("name", "Online Event") if venue else "Online Event"
            
            # Get price
            price = "Free"
            if event.get("is_free", False) is False:
                price_data = event.get("price", {})
                if price_data and "value" in price_data:
                    price = f"${price_data['value']} {price_data.get('currency', '')}"
            
            self.tree.insert(
                "", tk.END, 
                text=name,
                values=(date_str, venue_name, price)
            )
            
        self.status_var.set(f"Found {len(events)} events. Showing first {min(20, len(events))}")

    def format_date(self, date_str):
        try:
            dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%S")
            return dt.strftime("%b %d, %Y %I:%M %p")
        except ValueError:
            return date_str

if __name__ == "__main__":
    root = tk.Tk()
    app = EventFinder(root)
    root.mainloop()
